{"id":559581804,"lang":"java","time":"4 months, 3 weeks","timestamp":1632376509,"status_display":"Accepted","runtime":"6 ms","url":"/submissions/detail/559581804/","is_pending":"Not Pending","title":"Meeting Rooms II","memory":"38.6 MB","code":"class Solution {\n    public int minMeetingRooms(int[][] intervals) {\n        if(intervals.length == 0) return 0;\n        \n        // Min heap a priority queue where priority is given to\n        // minimum element.\n        // to find minimum number of rooms\n        // only get a new room when the we have a conflict.\n        \n        // add length of queue and initial comaprator to make it a min           // heap.\n        \n        PriorityQueue<Integer> alloc = new PriorityQueue<Integer>(intervals.length, new Comparator<Integer>(){\n            public int compare(Integer a, Integer b) {return a-b;}\n        });\n        \n        // sort the array according to earliest meeting times\n        Arrays.sort(intervals, new Comparator<int[]>(){\n            public int compare(int[] a, int[] b) {return a[0]-b[0];}\n        });\n        \n        alloc.add(intervals[0][1]);\n        \n        for(int i = 1; i < intervals.length; i++){\n            // if room is no longer occupied\n            // if start time of current meeting is after \n            // the end time of the one with allocated room\n            // then we can just use the same room for the current\n            // meeting.\n            if(intervals[i][0] >= alloc.peek()) alloc.poll();\n            //if not then alloc a new room.\n            alloc.add(intervals[i][1]);\n        }\n        // size of the min-heap is the number of rooms.\n        return alloc.size();\n    }\n}","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"meeting-rooms-ii"}