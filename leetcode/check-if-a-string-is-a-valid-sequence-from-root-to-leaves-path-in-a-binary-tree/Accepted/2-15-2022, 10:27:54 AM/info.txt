{"id":641660485,"lang":"rust","time":"2 days, 22 hours","timestamp":1644901074,"status_display":"Accepted","runtime":"14 ms","url":"/submissions/detail/641660485/","is_pending":"Not Pending","title":"Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree","memory":"2.8 MB","code":"// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\n#[allow(dead_code)]\nimpl Solution {\n    pub fn is_valid_sequence(root: Option<Rc<RefCell<TreeNode>>>, arr: Vec<i32>) -> bool {\n        if root.is_none() {\n             return false;\n        }\n        Self::check(&root, &arr, 0)\n    }\n    pub fn check(node: &Option<Rc<RefCell<TreeNode>>>, seq: &Vec<i32>, seq_idx: usize) -> bool {\n        if let Some(node) = node {\n            let node = node.borrow();\n            let left = &node.left;\n            let right = &node.right;\n            if seq_idx >= seq.len() || node.val != seq[seq_idx]{\n                return false;\n            }\n            if left.is_none() && right.is_none() && seq_idx == seq.len() - 1 && node.val == seq[seq_idx] {\n                return true;\n            }\n            Self::check(&node.left, seq, seq_idx+1) || Self::check(&node.right, seq, seq_idx+1)\n        } else {\n            false\n        }\n    }\n}","compare_result":"111111111111111111111111111111111111111111111111111111111111111","title_slug":"check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree"}